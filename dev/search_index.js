var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MacroEconometrics","category":"page"},{"location":"#MacroEconometrics","page":"Home","title":"MacroEconometrics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MacroEconometrics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MacroEconometrics]","category":"page"},{"location":"#MacroEconometrics.AbstractImpulseResponseFunction","page":"Home","title":"MacroEconometrics.AbstractImpulseResponseFunction","text":"Should have a field called variables::Vector{Symbol} containing the variables \nShould have a field called irfs::E<:Estimated containing the IRF estimates. Dimensions should be to×from×horizon\n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics.BayesianEstimated","page":"Home","title":"MacroEconometrics.BayesianEstimated","text":"Since conjugacy is incredibly rare and often not actually plausible (the priors are not plausible) in actual work, we will assume that all Bayesian estimated quantities are just samples, and can thus be put in an array. Additional meta data, such as warning information during sampling, etc can be put in the metadata field.\n\nBehaviour\n\nMost basic operations will directly be forwarded to the value field. As such, the type can be used like any other array, including multiplication with other arrays, iteration, etc.\n\nFields\n\nvalue::Array{T}: The actual values of the estimated quantity. Should be an Array; If multiple chains have been used, then the chains should be stacked along the last dimension; That is, if only a single chain is being used, then the last dimension should be of length 1. So for a matrix B that is n×n, we would have an array of dimensions n×n×d×c where d are the number of draws, and c is the number of chains.\nmetadata::M: Any additional data that one wishes to save relating to the estimation. This could be warnings from the sampling algorithms, etc.\n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics.Estimated","page":"Home","title":"MacroEconometrics.Estimated","text":"The idea is to abstract he model from the way it has been estimated. In it's most essential form, a model is just a struct, with the same structure no matter how is has been estimated. The only time that estimation matter is when statistics about estimated quantities are asked for. Thus, any statistic that needs to be estimated in a model should be of type Estimated. Estimated itself can then be either Frequentist or Bayesian.\n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics.FixedEstimated","page":"Home","title":"MacroEconometrics.FixedEstimated","text":"\"   Fixing the estimation.\n\nSometimes we want to fix a parameter to a specific value. Although this parameter is no-longer technically estimated, it is still an estimable quantity and thus is still a subtype of Estimated. \n\nFields\n\n-value::Array{T}: The value of the quantity\n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics.FrequentistEstimated","page":"Home","title":"MacroEconometrics.FrequentistEstimated","text":"Frequentist estimations usually consist of a point estimate and a confidence interval. If Bootstrapping is used, the confidence interval must not be symmetric. As such, having a separate lower and upper CI allows for asymmetric CIs. \n\nBehaviour\n\nMost operations are directly forwarded to the value field. For example, additiona, subtraction, ... are all forwarded to the value field. So is indexing. \n\nFields\n\nvalue::Array{T}: The point estimates. \nci_lower::Array{T}: The lower end of the CI for each value in values\nci_upper::Array{T}: The upper end of the CI for each value in values\nmetadata::M: Any metadata. Should, for example, include the level of the CI.\n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics.IRFCovarianceNormalisation","page":"Home","title":"MacroEconometrics.IRFCovarianceNormalisation","text":"Variance of structural shocks is normalised to unity.\n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics.IRFImpactNormalisation","page":"Home","title":"MacroEconometrics.IRFImpactNormalisation","text":"Impact of structural shock on variable is normalised to unity. That is, each structural shock has a variable which it increases by one unit if the shock increases by one unit. \n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics.OlsVAREstimator","page":"Home","title":"MacroEconometrics.OlsVAREstimator","text":"OlsVAREstimator(intercept::Bool=true; confint_level=0.95)\n\nOLS estimator for a VAR\n\nEstimate VAR coefficients equation by equation using OLS. This uses the lm method in GLS.jl\n\nFields\n\nintercept::Bool: Should an intercept be estimated? \nconfint_level::Real: Confidence level; Confidence intervals are symmetric and are using the asymptotic normal approximation. \n\nReferences\n\nLütkepohl, H. (2005). New introduction to multiple time series analysis. New York: Springer. (page 72 below equation 3.2.12)\n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics.VAR","page":"Home","title":"MacroEconometrics.VAR","text":"VAR(n::Int, p::Int, B::E, b0::E, Σ::E, data::TSFrame) where {E<:Estimated}\nVAR(data::TSFrame, p; type::Type{T}=BayesianEstimated)\nVAR(n::Int, p::Int, B::FixedEstimated{T}, b0::FixedEstimated{T}, Σ::FixedEstimated{T}) where {T}\n\nEvery VAR model is of the form\n\ny_t = b_0 + B_1 y_t-1 +  + B_p y_t-p + varepsilon_t\n\nwhere B_i is n times n and b_0 is an n times 1 vector. For the disturbance terms, varepsilon_t we generally assume varepsilon_t sim N(0 Sigma). This can therefore be equivelently written as \n\ny_t = b_0 + B tildey_t-1 + varepsilon_t\n\nwhere B is now n times np and tildey_t-1=(y_t-1  y_t-p).\n\nGeneral Information\n\nVAR models are only approprite for regularly spaced observations. We therefore check whether this is the case here\n\nFields\n\nn::Int: Number of variables in the VAR.\np::Int: Numbe of lags; See the equations above.\nB::Union{Nothing, E<:Estimated}: Lag coefficient matrix; See the equations above; Should be a subtype of Estimated. \nb0::Union{Nothing, E<:Estimated}: Intercept vector; See equations above.\nΣ::Union{Nothing, E<:Estimated}: Covariance matrix of disturbance terms; See equation above.\ndata::Union{Nothing, TSFrame}: A time series data frame containing the data used for the VAR. Observations should be regularly spaced.\n\n\n\n\n\n","category":"type"},{"location":"#MacroEconometrics._check_regularity_data-Tuple{TSFrames.TSFrame}","page":"Home","title":"MacroEconometrics._check_regularity_data","text":" Check whether data is of a regular and known frequency.\n\nArguments\n\ndata::TSFrame: Time series data\n\n\n\n\n\n","category":"method"},{"location":"#MacroEconometrics._lag_ts-Union{Tuple{T}, Tuple{TSFrames.TSFrame, AbstractVector{T}}} where T","page":"Home","title":"MacroEconometrics._lag_ts","text":"Create a lagged TSFrame.\n\nArguments\n\nts::TSFrame: TSFrame to lag\nlag_value::Union{OrdinalRange{T, T}, AbstractVector{T}}: lags\n\nKeyword Arguments\n\nname_attach::String=\"__L\": String to attach to variable names\nremove_fist::Bool=true: Remove the first few rows tha will be missing for the lagged variables?\n\n\n\n\n\n","category":"method"},{"location":"#MacroEconometrics._simulate_VAR-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, Int64}} where T","page":"Home","title":"MacroEconometrics._simulate_VAR","text":"Simulate a Gaussian VAR\n\nArguments\n\nB::AbstractMatrix{T}: Lag matrix of dimensions n×(n*p)\nb0::AbstractVector{T}: Vector of intercepts of dimension n×1\nΣ::AbstractMatrix{T}: Covariance matrix of errors of dimension n×n\ninitial::AbstractVector{T}: Initial values of dimension (n*p)×1; So it is the initial value of the companion form.\nperiods::Int: Number of periods to simulate for. \n\nKeyword arguments\n\nburnin::Int=100: Number of periods to use as burnin. This will reduce the dependency on the initial conditions. \nrng::Random.AbstractRNG=Random.MersenneTwister(): Random number generator. \n\nReturns\n\nReturns a matrix Y of dimensions n×periods; Thus, rows are the variables, columns are the time points. \n\n\n\n\n\n","category":"method"},{"location":"#MacroEconometrics.estimate!-Tuple{AbstractVectorAutoregression, AbstractVAREstimator, Vararg{Any}}","page":"Home","title":"MacroEconometrics.estimate!","text":"estimate!(var::AbstractVectorAutoregression, method::AbstractVAREstimator, args...; kwargs...)\n\nEstimate a VAR using method.\n\nMethods\n\nDepending on the type of VAR, the methods can differ. Methods can also differ with regard to which statistical paradigm they are following. Some methods will estimate the VAR using Frequentist methods, while others will estimate the VAR using Bayesian methods. \n\nStandard Gaussian VAR: VAR\n\nThis is represented by a standard VAR type. Methods currently include\n\nOlsVAREstimator\n\n\n\n\n\n","category":"method"},{"location":"#MacroEconometrics.is_stable-Tuple{AbstractVectorAutoregression}","page":"Home","title":"MacroEconometrics.is_stable","text":"is_stable(var::AbstractVectorAutoregression)\n\nCheck whether the VAR is stable. \n\nGiven a companionmatrix C of a VAR, the VAR is considered stable if and only if all eigenvalues of C are less than unity in absolute value.  \n\nArguments\n\nvar::Estimated: The VAR model\n\nReferences\n\nKilian, L., & Lütkepohl, H. (2017). Structural Vector Autoregressive Analysis: (1st ed.). Cambridge University Press. https://doi.org/10.1017/9781108164818\n\n\n\n\n\n","category":"method"},{"location":"#MacroEconometrics.is_stable-Union{Tuple{VAR{BayesianEstimated{T, M}}}, Tuple{M}, Tuple{T}} where {T, M}","page":"Home","title":"MacroEconometrics.is_stable","text":"is_stable(var::VAR{BayesianEstimated{T, M}}) where {T, M}\n\nIn case of Bayesian estimated VARs, the model is considered stable if and only if the VAR is stable for all parameter draws. As such, a rather strong view is taken here. \n\n\n\n\n\n","category":"method"},{"location":"#MacroEconometrics.make_companion_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"MacroEconometrics.make_companion_matrix","text":"make_companion(B::AbstractMatrix{T}) where {T}\n\nCreate the VAR companion matrix.\n\nGiven a VAR of the form\n\ny_t = b_0 + B_1 y_t-1 +  + B_p y_t-p + varepsilon_t\n\nThe companion matrix is given by \n\nC = beginbmatrix\n    B_1  B_2  dots  B_p-1  B_p \n    I_n  O  dots  O  O \n    O  I_n   O  O \n    vdots   ddots  vdots  vdots  \n    O  O  dots  I_n  O\nendbmatrix\n\nThus, B is a nptimes np matrix. \n\nArguments\n\n-B::AbstractMatrix{T}: Lag matrix in the form required for a VAR model. See     the documentation of VAR.\n\nReferences\n\nKilian, L., & Lütkepohl, H. (2017). Structural Vector Autoregressive Analysis: (1st ed.). Cambridge University Press. https://doi.org/10.1017/9781108164818\n\n\n\n\n\n","category":"method"},{"location":"#MacroEconometrics.make_companion_matrix-Union{Tuple{VAR{FixedEstimated{T}}}, Tuple{T}} where T","page":"Home","title":"MacroEconometrics.make_companion_matrix","text":"make_companion_matrix(var::VAR{FixedEstimated{T}}) where {T}\nmake_companion_matrix(var::VAR{BayesianEstimated{T, M}}) where {T, M}\n\nMake the companion matrix corresponding to a VAR model. In case of Bayesian estimated models, the companion matrix is constructed for each draw in each chain.\n\n\n\n\n\n","category":"method"},{"location":"#MacroEconometrics.simulate!-Union{Tuple{T}, Tuple{VAR{FixedEstimated{T}}, Int64}} where T","page":"Home","title":"MacroEconometrics.simulate!","text":"Simulate a Gaussian VAR. \n\nArguments\n\nvar::VAR{FixedEstimated{T}}: A VAR model having FixedEstimated coefficients.\nperiods::Int: Number of periods to simulate the VAR for\n\nKeyword Arguments\n\nburnin::Int=100: Number of periods to use as burnin; The longe the burnin, the less the dependence on the initial values. \ninitial::AbstractVector{T}=zeros(T, var.n*var.p): Initial values. Should be in companion form, so a vector of length var.n×var.p\nstart_date::Date=Dates.today(): The simulated data will be stored in a TSFrame including dates. Thus, we need a start date. \nfrequency::DatePeriod=Dates.Quarter(1): Frequency of data. \nrng::Random.AbstractRNG=Random.MersenneTwister(): Random Number Generator\n\nReturns\n\nReturns the same VAR model. The data field in the VAR model is overwritten witht he new simulated data.\n\n\n\n\n\n","category":"method"},{"location":"#TSFrames.lag-Union{Tuple{T}, Tuple{TSFrames.TSFrame, AbstractVector{T}}} where T","page":"Home","title":"TSFrames.lag","text":"If lag_value is a range or a vector of lags, then a vector of TSFrames will be returned where each element of the vector is one lagged TSFrame.\n\n\n\n\n\n","category":"method"}]
}
