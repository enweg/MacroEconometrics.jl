<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MacroEconometrics.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://enweg.github.io/MacroEconometrics.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MacroEconometrics.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/enweg/MacroEconometrics.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MacroEconometrics"><a class="docs-heading-anchor" href="#MacroEconometrics">MacroEconometrics</a><a id="MacroEconometrics-1"></a><a class="docs-heading-anchor-permalink" href="#MacroEconometrics" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/enweg/MacroEconometrics.jl">MacroEconometrics</a>.</p><ul><li><a href="#MacroEconometrics.AbstractImpulseResponseFunction"><code>MacroEconometrics.AbstractImpulseResponseFunction</code></a></li><li><a href="#MacroEconometrics.BayesianEstimated"><code>MacroEconometrics.BayesianEstimated</code></a></li><li><a href="#MacroEconometrics.Estimated"><code>MacroEconometrics.Estimated</code></a></li><li><a href="#MacroEconometrics.FixedEstimated"><code>MacroEconometrics.FixedEstimated</code></a></li><li><a href="#MacroEconometrics.FrequentistEstimated"><code>MacroEconometrics.FrequentistEstimated</code></a></li><li><a href="#MacroEconometrics.IRFCovarianceNormalisation"><code>MacroEconometrics.IRFCovarianceNormalisation</code></a></li><li><a href="#MacroEconometrics.IRFImpactNormalisation"><code>MacroEconometrics.IRFImpactNormalisation</code></a></li><li><a href="#MacroEconometrics.ImpulseResponseFunction-Union{Tuple{E}, Tuple{VAR{E}, Int64}} where E&lt;:BayesianEstimated"><code>MacroEconometrics.ImpulseResponseFunction</code></a></li><li><a href="#MacroEconometrics.IndependentNormalWishart"><code>MacroEconometrics.IndependentNormalWishart</code></a></li><li><a href="#MacroEconometrics.OlsVAREstimator"><code>MacroEconometrics.OlsVAREstimator</code></a></li><li><a href="#MacroEconometrics.SVAR"><code>MacroEconometrics.SVAR</code></a></li><li><a href="#MacroEconometrics.StructuralImpulseResponseFunction-Union{Tuple{E}, Tuple{VAR{E}, Int64, CholeskyVAR}} where E&lt;:BayesianEstimated"><code>MacroEconometrics.StructuralImpulseResponseFunction</code></a></li><li><a href="#MacroEconometrics.VAR"><code>MacroEconometrics.VAR</code></a></li><li><a href="#MacroEconometrics._check_regularity_data-Tuple{TSFrames.TSFrame}"><code>MacroEconometrics._check_regularity_data</code></a></li><li><a href="#MacroEconometrics._lag_ts-Union{Tuple{T}, Tuple{TSFrames.TSFrame, AbstractVector{T}}} where T"><code>MacroEconometrics._lag_ts</code></a></li><li><a href="#MacroEconometrics._simulate_VAR-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, Int64}} where T"><code>MacroEconometrics._simulate_VAR</code></a></li><li><a href="#MacroEconometrics._var_irf!-Tuple{AbstractArray, AbstractMatrix}"><code>MacroEconometrics._var_irf!</code></a></li><li><a href="#MacroEconometrics.create_minnesota_params-Union{Tuple{T}, Tuple{E}, Tuple{VAR{E}, T, T}} where {E&lt;:Estimated, T&lt;:Real}"><code>MacroEconometrics.create_minnesota_params</code></a></li><li><a href="#MacroEconometrics.estimate!-Tuple{AbstractVectorAutoregression, AbstractVAREstimator, Vararg{Any}}"><code>MacroEconometrics.estimate!</code></a></li><li><a href="#MacroEconometrics.is_stable-Union{Tuple{VAR{BayesianEstimated{T, M}}}, Tuple{M}, Tuple{T}} where {T, M}"><code>MacroEconometrics.is_stable</code></a></li><li><a href="#MacroEconometrics.is_stable-Tuple{AbstractVectorAutoregression}"><code>MacroEconometrics.is_stable</code></a></li><li><a href="#MacroEconometrics.make_companion_matrix-Union{Tuple{VAR{FixedEstimated{T}}}, Tuple{T}} where T"><code>MacroEconometrics.make_companion_matrix</code></a></li><li><a href="#MacroEconometrics.make_companion_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>MacroEconometrics.make_companion_matrix</code></a></li><li><a href="#MacroEconometrics.simulate!-Union{Tuple{T}, Tuple{SVAR{FixedEstimated{T}}, Int64}} where T"><code>MacroEconometrics.simulate!</code></a></li><li><a href="#MacroEconometrics.simulate!-Union{Tuple{T}, Tuple{VAR{FixedEstimated{T}}, Int64}} where T"><code>MacroEconometrics.simulate!</code></a></li><li><a href="#MacroEconometrics.stack_last_dim-Tuple{AbstractArray}"><code>MacroEconometrics.stack_last_dim</code></a></li><li><a href="#MacroEconometrics.to_impact_normalisation-Tuple{S} where S&lt;:StructuralImpulseResponseFunction"><code>MacroEconometrics.to_impact_normalisation</code></a></li><li><a href="#TSFrames.lag-Union{Tuple{T}, Tuple{TSFrames.TSFrame, AbstractVector{T}}} where T"><code>TSFrames.lag</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.AbstractImpulseResponseFunction" href="#MacroEconometrics.AbstractImpulseResponseFunction"><code>MacroEconometrics.AbstractImpulseResponseFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><ul><li>Should have a field called <code>variables::Vector{Symbol}</code> containing the variables </li><li>Should have a field called <code>irfs::E&lt;:Estimated</code> containing the IRF estimates. Dimensions should be to×from×horizon</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/IRF/types.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.BayesianEstimated" href="#MacroEconometrics.BayesianEstimated"><code>MacroEconometrics.BayesianEstimated</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Since conjugacy is incredibly rare and often not actually plausible (the priors are not plausible) in actual work, we will assume that all Bayesian estimated quantities are just samples, and can thus be put in an array. Additional meta data, such as warning information during sampling, etc can be put in the metadata field.</p><p><strong>Behaviour</strong></p><ul><li>Most basic operations will directly be forwarded to the value field. As such, the type can be used like any other array, including multiplication with other arrays, iteration, etc.</li></ul><p><strong>Fields</strong></p><ul><li><code>value::Array{T}</code>: The actual values of the estimated quantity. Should be an Array; If multiple chains have been used, then the chains should be stacked along the last dimension; That is, if only a single chain is being used, then the last dimension should be of length 1. So for a matrix B that is n×n, we would have an array of dimensions n×n×d×c where d are the number of draws, and c is the number of chains.</li><li><code>metadata::M</code>: Any additional data that one wishes to save relating to the estimation. This could be warnings from the sampling algorithms, etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/estimated.jl#L41-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.Estimated" href="#MacroEconometrics.Estimated"><code>MacroEconometrics.Estimated</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The idea is to abstract he model from the way it has been estimated. In it&#39;s most essential form, a model is just a struct, with the same structure no matter how is has been estimated. The only time that estimation matter is when statistics about estimated quantities are asked for. Thus, any statistic that needs to be estimated in a model should be of type Estimated. Estimated itself can then be either Frequentist or Bayesian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/estimated.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.FixedEstimated" href="#MacroEconometrics.FixedEstimated"><code>MacroEconometrics.FixedEstimated</code></a> — <span class="docstring-category">Type</span></header><section><div><p>&quot;   Fixing the estimation.</p><p>Sometimes we want to fix a parameter to a specific value. Although this parameter is no-longer technically estimated, it is still an estimable quantity and thus is still a subtype of Estimated. </p><p><strong>Fields</strong></p><p>-<code>value::Array{T}</code>: The value of the quantity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/estimated.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.FrequentistEstimated" href="#MacroEconometrics.FrequentistEstimated"><code>MacroEconometrics.FrequentistEstimated</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Frequentist estimations usually consist of a point estimate and a confidence interval. If Bootstrapping is used, the confidence interval must not be symmetric. As such, having a separate lower and upper CI allows for asymmetric CIs. </p><p><strong>Behaviour</strong></p><p>Most operations are directly forwarded to the value field. For example, additiona, subtraction, ... are all forwarded to the <code>value</code> field. So is indexing. </p><p><strong>Fields</strong></p><ul><li><code>value::Array{T}</code>: The point estimates. </li><li><code>ci_lower::Array{T}</code>: The lower end of the CI for each value in <code>values</code></li><li><code>ci_upper::Array{T}</code>: The upper end of the CI for each value in <code>values</code></li><li><code>metadata::M</code>: Any metadata. Should, for example, include the level of the CI.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/estimated.jl#L83-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.IRFCovarianceNormalisation" href="#MacroEconometrics.IRFCovarianceNormalisation"><code>MacroEconometrics.IRFCovarianceNormalisation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Variance of structural shocks is normalised to unity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/IRF/types.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.IRFImpactNormalisation" href="#MacroEconometrics.IRFImpactNormalisation"><code>MacroEconometrics.IRFImpactNormalisation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Impact of structural shock on variable is normalised to unity. That is, each structural shock has a variable which it increases by one unit if the shock increases by one unit. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/IRF/types.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.ImpulseResponseFunction-Union{Tuple{E}, Tuple{VAR{E}, Int64}} where E&lt;:BayesianEstimated" href="#MacroEconometrics.ImpulseResponseFunction-Union{Tuple{E}, Tuple{VAR{E}, Int64}} where E&lt;:BayesianEstimated"><code>MacroEconometrics.ImpulseResponseFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ImpulseResponseFunction(var::VAR{E}, horizon::Int) where {E &lt;: BayesianEstimated}</code></pre><p>Calculate the reduced form IRFs of a <a href="#MacroEconometrics.VAR"><code>VAR</code></a> model. </p><p><strong>Arguments</strong></p><ul><li><code>var::VAR{&lt;:BayesianEstimated}</code>: A <a href="#MacroEconometrics.VAR"><code>VAR</code></a> model estimated using Bayesian estimation methods</li><li><code>horizon::Int</code>: Maximum IRF horizon. </li></ul><p><strong>Retruns</strong></p><ul><li>Returns a tensor of dimension to×from×horizon×draw×chain. This can be flattened to a tensor of dimensions to×from×horizon×draw*chain using <a href="#MacroEconometrics.stack_last_dim-Tuple{AbstractArray}"><code>stack_last_dim</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/irf.jl#L18-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.IndependentNormalWishart" href="#MacroEconometrics.IndependentNormalWishart"><code>MacroEconometrics.IndependentNormalWishart</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Estimate a VAR using a Independent Normal-Wishart prior. </p><p>Given a standard VAR, we can assume the following priors: </p><p class="math-container">\[\begin{split}
\beta \sim N(\beta_0, V_0) \\
\Sigma^{-1} \sim Wishart(S_0^{-1}, \nu_0)
\end{split}\]</p><p>where <span>$\beta$</span> is the vector of all VAR coefficients (each equations parameters stacked above each other) and where <span>$\Sigma$</span> is the covariance matrix of the error terms.</p><p>This then results in the conditional posteriors</p><p class="math-container">\[\begin{split}
\beta | Y, \Sigma^{-1} &amp;\sim N(\bar\beta, \bar{V}) \\
\bar{V} &amp;= \left(V_0^{-1} + \sum_{t=1}^T Z_t&#39;\Sigma^{-1}Z_t\right)^{-1} \\
\bar\beta &amp;= \bar{V}\left(V_0^{-1}\beta_0 + \sum_{t=1}^T Z_t&#39;\Sigma^{-1}y_t\right)
\end{split}\]</p><p>and </p><p class="math-container">\[\Sigma^{-1}|Y, \beta &amp;\sim Wishart(\bar{S}^{-1}, \bar\nu) \\
\bar\nu &amp;= T + \nu_0 \\
\bar{S} &amp;= S_0 + \sum_{t=1}^T (y_t - Z_t\beta)(y_t - Z_t\beta)&#39;\]</p><p>where <span>$y_t$</span> is the outcome vector at time t, and where <span>$Z_t = I_n \otimes (1, y_{t-1}&#39;, ..., y_{t-p}&#39;)$</span>.</p><p><strong>Fields</strong></p><ul><li><code>prior_β::AbsatractVector{T}</code>: Prior mean of the coefficients. </li><li><code>prior_V::AbstractMatrix{T}</code>: Prior covariance of coefficients. </li><li><code>prior_S::AbstractMatrix{T}</code>: Prior scale matrix. </li><li><code>prior_ν::T</code>: Prior degrees of freedom. </li><li><code>intercept::Bool</code>: Estimate an intercept.</li></ul><p><strong>References</strong></p><ul><li>Koop, G., &amp; Korobilis, D. (Eds.). (2010). Bayesian multivariate time series methods for emprirical macroeconomics. now.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/estimation.jl#L65-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.OlsVAREstimator" href="#MacroEconometrics.OlsVAREstimator"><code>MacroEconometrics.OlsVAREstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OlsVAREstimator(intercept::Bool=true; confint_level=0.95)</code></pre><p>OLS estimator for a VAR</p><p>Estimate VAR coefficients equation by equation using OLS. This uses the <code>lm</code> method in <code>GLS.jl</code></p><p><strong>Fields</strong></p><ul><li><code>intercept::Bool</code>: Should an intercept be estimated? </li><li><code>confint_level::Real</code>: Confidence level; Confidence intervals are symmetric and are using the asymptotic normal approximation. </li></ul><p><strong>References</strong></p><ul><li>Lütkepohl, H. (2005). New introduction to multiple time series analysis. New York: Springer. (page 72 below equation 3.2.12)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/estimation.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.SVAR" href="#MacroEconometrics.SVAR"><code>MacroEconometrics.SVAR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SVAR(n::Int, p::Int, B::E, b0::E, Σ::E, data::TSFrame) where {E&lt;:Estimated}
SVAR(data::TSFrame, p; type::Type{T}=BayesianEstimated)
SVAR(n::Int, p::Int, B::FixedEstimated{T}, b0::FixedEstimated{T}, Σ::FixedEstimated{T}) where {T}</code></pre><p>Every SVAR model is of the form</p><p class="math-container">\[A y_t = b_0 + B_1 y_{t-1} + ... + B_p y_{t-p} + \varepsilon_t\]</p><p>where <span>$A$</span> is a <span>$n \times n$</span> contemporanous matrix, <span>$B_i$</span> is <span>$n \times n$</span> and <span>$b_0$</span> is an <span>$n \times 1$</span> vector. For the disturbance terms, <span>$\varepsilon_t$</span> we generally assume <span>$\varepsilon_t \sim N(0, \Sigma)$</span>. This can therefore be equivelently written as </p><p class="math-container">\[A y_t = b_0 + B \tilde{y}_{t-1} + \varepsilon_t\]</p><p>where <span>$B$</span> is now <span>$n \times np$</span> and <span>$\tilde{y}_{t-1}=(y_{t-1}&#39;, ..., y_{t-p}&#39;)&#39;$</span>.</p><p><strong>General Information</strong></p><ul><li>SVAR models are only approprite for regularly spaced observations. We therefore check whether this is the case here</li></ul><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Number of variables in the VAR.</li><li><code>p::Int</code>: Numbe of lags; See the equations above.</li><li><code>A::Union{Nothing, E&lt;:Estimated}</code>: Contemporanous matrix; See the equations above;</li><li><code>B::Union{Nothing, E&lt;:Estimated}</code>: Lag coefficient matrix; See the equations above; Should be a subtype of <code>Estimated</code>. </li><li><code>b0::Union{Nothing, E&lt;:Estimated}</code>: Intercept vector; See equations above.</li><li><code>Σ::Union{Nothing, E&lt;:Estimated}</code>: Covariance matrix of disturbance terms; See equation above.</li><li><code>data::Union{Nothing, TSFrame}</code>: A time series data frame containing the data used for the VAR. Observations should be regularly spaced.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/types.jl#L124-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.StructuralImpulseResponseFunction-Union{Tuple{E}, Tuple{VAR{E}, Int64, CholeskyVAR}} where E&lt;:BayesianEstimated" href="#MacroEconometrics.StructuralImpulseResponseFunction-Union{Tuple{E}, Tuple{VAR{E}, Int64, CholeskyVAR}} where E&lt;:BayesianEstimated"><code>MacroEconometrics.StructuralImpulseResponseFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructuralImpulseResponseFunction(var::VAR{&lt;:BayesianEstimated}, horizon::Int, identification_method::CholeskyVAR)</code></pre><p>Estimate Structural Impulse Response Functions using a Cholesky decomposition. </p><p>The reduced form covariance matrix is given by <span>$A^{-1}\Sigma A^{-1}&#39;$</span>. If we normalise the structural covariance matrix <span>$\Sigma = I$</span>, then the reduced form covariance matrix is given by <span>$A^{-1}A^{-1}&#39;$</span>. Thus, if we assume that <span>$A$</span> takes a lower-triangular form, then we can estimate <span>$A$</span> and <span>$A^{-1}$</span> from the reduced form covariance matrix by obtaining the lower-triangular cholesky matrix of the reduced form covariance matrix. Since the covariance matrix is positive semi-definite, this lower-triangular matrix is unique. </p><p><strong>Arguments</strong></p><ul><li><code>var::VAR{&lt;:BayesianEstimated}</code>: A <a href="#MacroEconometrics.VAR"><code>VAR</code></a> model estimated in a Bayesian way</li><li><code>horizon::Int</code>: Maximum horizon of IRFs. </li><li><code>identification_method::CholeskyVAR</code>: Identification method.</li></ul><p><strong>Returns</strong></p><ul><li>Returns a tensor of dimension to×from×horizon×draw×chain. This can be flattened to a tensor of dimensions to×from×horizon×draw*chain using <a href="#MacroEconometrics.stack_last_dim-Tuple{AbstractArray}"><code>stack_last_dim</code></a>.</li></ul><p><strong>References</strong></p><ul><li>Kilian, L., &amp; Lütkepohl, H. (2017). Structural Vector Autoregressive Analysis: (1st ed.). Cambridge University Press. https://doi.org/10.1017/9781108164818</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/irf.jl#L51-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.VAR" href="#MacroEconometrics.VAR"><code>MacroEconometrics.VAR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VAR(n::Int, p::Int, B::E, b0::E, Σ::E, data::TSFrame) where {E&lt;:Estimated}
VAR(data::TSFrame, p; type::Type{T}=BayesianEstimated)
VAR(n::Int, p::Int, B::FixedEstimated{T}, b0::FixedEstimated{T}, Σ::FixedEstimated{T}) where {T}</code></pre><p>Every VAR model is of the form</p><p class="math-container">\[y_t = b_0 + B_1 y_{t-1} + ... + B_p y_{t-p} + \varepsilon_t\]</p><p>where <span>$B_i$</span> is <span>$n \times n$</span> and <span>$b_0$</span> is an <span>$n \times 1$</span> vector. For the disturbance terms, <span>$\varepsilon_t$</span> we generally assume <span>$\varepsilon_t \sim N(0, \Sigma)$</span>. This can therefore be equivelently written as </p><p class="math-container">\[y_t = b_0 + B \tilde{y}_{t-1} + \varepsilon_t\]</p><p>where <span>$B$</span> is now <span>$n \times np$</span> and <span>$\tilde{y}_{t-1}=(y_{t-1}&#39;, ..., y_{t-p}&#39;)&#39;$</span>.</p><p><strong>General Information</strong></p><ul><li>VAR models are only approprite for regularly spaced observations. We therefore check whether this is the case here</li></ul><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Number of variables in the VAR.</li><li><code>p::Int</code>: Numbe of lags; See the equations above.</li><li><code>B::Union{Nothing, E&lt;:Estimated}</code>: Lag coefficient matrix; See the equations above; Should be a subtype of <code>Estimated</code>. </li><li><code>b0::Union{Nothing, E&lt;:Estimated}</code>: Intercept vector; See equations above.</li><li><code>Σ::Union{Nothing, E&lt;:Estimated}</code>: Covariance matrix of disturbance terms; See equation above.</li><li><code>data::Union{Nothing, TSFrame}</code>: A time series data frame containing the data used for the VAR. Observations should be regularly spaced.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/types.jl#L50-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics._check_regularity_data-Tuple{TSFrames.TSFrame}" href="#MacroEconometrics._check_regularity_data-Tuple{TSFrames.TSFrame}"><code>MacroEconometrics._check_regularity_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> Check whether data is of a regular and known frequency.</code></pre><p><strong>Arguments</strong></p><ul><li><code>data::TSFrame</code>: Time series data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/utils.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics._lag_ts-Union{Tuple{T}, Tuple{TSFrames.TSFrame, AbstractVector{T}}} where T" href="#MacroEconometrics._lag_ts-Union{Tuple{T}, Tuple{TSFrames.TSFrame, AbstractVector{T}}} where T"><code>MacroEconometrics._lag_ts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a lagged TSFrame.</p><p><strong>Arguments</strong></p><ul><li><code>ts::TSFrame</code>: TSFrame to lag</li><li><code>lag_value::Union{OrdinalRange{T, T}, AbstractVector{T}}</code>: lags</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>name_attach::String=&quot;__L&quot;</code>: String to attach to variable names</li><li><code>remove_fist::Bool=true</code>: Remove the first few rows tha will be <code>missing</code> for the lagged variables?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/utils.jl#L30-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics._simulate_VAR-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, Int64}} where T" href="#MacroEconometrics._simulate_VAR-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, Int64}} where T"><code>MacroEconometrics._simulate_VAR</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simulate a Gaussian VAR</p><p><strong>Arguments</strong></p><ul><li><code>B::AbstractMatrix{T}</code>: Lag matrix of dimensions n×(n*p)</li><li><code>b0::AbstractVector{T}</code>: Vector of intercepts of dimension n×1</li><li><code>Σ::AbstractMatrix{T}</code>: Covariance matrix of errors of dimension n×n</li><li><code>initial::AbstractVector{T}</code>: Initial values of dimension (n*p)×1; So it is the initial value of the companion form.</li><li><code>periods::Int</code>: Number of periods to simulate for. </li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>burnin::Int=100</code>: Number of periods to use as burnin. This will reduce the dependency on the initial conditions. </li><li><code>rng::Random.AbstractRNG=Random.MersenneTwister()</code>: Random number generator. </li></ul><p><strong>Returns</strong></p><ul><li>Returns a matrix <code>Y</code> of dimensions n×periods; Thus, rows are the variables, columns are the time points. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/simulation.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics._var_irf!-Tuple{AbstractArray, AbstractMatrix}" href="#MacroEconometrics._var_irf!-Tuple{AbstractArray, AbstractMatrix}"><code>MacroEconometrics._var_irf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_var_irf!(irfs::AbstractArray, B::AbstractMatrix)</code></pre><p>Calculate the IRF of a reduced form VAR model with lag coefficient matrix <code>B</code>. Save these results in <code>irfs</code>. <code>irfs</code> must have dimensions nvars×nvars×horizons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/irf.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.create_minnesota_params-Union{Tuple{T}, Tuple{E}, Tuple{VAR{E}, T, T}} where {E&lt;:Estimated, T&lt;:Real}" href="#MacroEconometrics.create_minnesota_params-Union{Tuple{T}, Tuple{E}, Tuple{VAR{E}, T, T}} where {E&lt;:Estimated, T&lt;:Real}"><code>MacroEconometrics.create_minnesota_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_minnesota_params(
    var::VAR{E},
    λ::T,
    θ::T;
    mean_first_own_lag::T=1.0,
    mean_other_lags::T=0.0,
    include_intercept::Bool=true,
    mean_intercept::T=0.0,
    variance_intercept::T=10.0
) where {E&lt;:Estimated,T}</code></pre><p>Crate the mean and covariance of a minnesota prior on the coefficients of a VAR. These can then be used as the prior mean anf variance of the VAR coefficients in the <a href="#MacroEconometrics.IndependentNormalWishart"><code>IndependentNormalWishart</code></a> prior.</p><p><strong>Arguments</strong></p><ul><li><code>var::VAR{&lt;:Estimated}</code>: a <a href="#MacroEconometrics.VAR"><code>VAR</code></a> model.</li><li><code>λ::&lt;:Real</code>: prior standard deviation on the first own lag. </li><li><code>θ::&lt;:Real</code>: relative tightness of the prior standard deviation in other lags. 0 &lt; θ &lt; 1</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mean_first_own_lag::&lt;:Real=1.0</code>: Mean on the first own lag. </li><li><code>mean_other_lags::&lt;:Real=0.0</code>: Mean on other lags than the first own lag. </li><li><code>include_intercept::Bool=true</code>: Should an intercept be included. Intercepts are the first two elements in the returned mean vector. </li><li><code>mean_intercept::&lt;:Real=0.0</code>: Mean of the intercept. </li><li><code>variance_intercept::&lt;:Real=10.0</code>: Variance on the intercept. Commonly chosen quite large. </li></ul><p><strong>References</strong></p><ul><li>Kilian, L., &amp; Lütkepohl, H. (2017). Structural Vector Autoregressive Analysis: (1st ed.). Cambridge University Press. https://doi.org/10.1017/9781108164818</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/estimation.jl#L171-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.estimate!-Tuple{AbstractVectorAutoregression, AbstractVAREstimator, Vararg{Any}}" href="#MacroEconometrics.estimate!-Tuple{AbstractVectorAutoregression, AbstractVAREstimator, Vararg{Any}}"><code>MacroEconometrics.estimate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimate!(var::AbstractVectorAutoregression, method::AbstractVAREstimator, args...; kwargs...)</code></pre><p>Estimate a VAR using <code>method</code>.</p><p><strong>Methods</strong></p><p>Depending on the type of VAR, the methods can differ. Methods can also differ with regard to which statistical paradigm they are following. Some methods will estimate the VAR using Frequentist methods, while others will estimate the VAR using Bayesian methods. </p><p><strong>Standard Gaussian VAR: <a href="#MacroEconometrics.VAR"><code>VAR</code></a></strong></p><p>This is represented by a standard <a href="#MacroEconometrics.VAR"><code>VAR</code></a> type. Methods currently include</p><ul><li><a href="#MacroEconometrics.OlsVAREstimator"><code>OlsVAREstimator</code></a></li><li><a href="#MacroEconometrics.IndependentNormalWishart"><code>IndependentNormalWishart</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/types.jl#L6-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.is_stable-Tuple{AbstractVectorAutoregression}" href="#MacroEconometrics.is_stable-Tuple{AbstractVectorAutoregression}"><code>MacroEconometrics.is_stable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_stable(var::AbstractVectorAutoregression)</code></pre><p>Check whether the VAR is stable. </p><p>Given a companionmatrix C of a VAR, the VAR is considered stable if and only if all eigenvalues of C are less than unity in absolute value.  </p><p><strong>Arguments</strong></p><ul><li><code>var::Estimated</code>: The VAR model</li></ul><p><strong>References</strong></p><ul><li>Kilian, L., &amp; Lütkepohl, H. (2017). Structural Vector Autoregressive Analysis: (1st ed.). Cambridge University Press. https://doi.org/10.1017/9781108164818</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/types.jl#L30-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.is_stable-Union{Tuple{VAR{BayesianEstimated{T, M}}}, Tuple{M}, Tuple{T}} where {T, M}" href="#MacroEconometrics.is_stable-Union{Tuple{VAR{BayesianEstimated{T, M}}}, Tuple{M}, Tuple{T}} where {T, M}"><code>MacroEconometrics.is_stable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_stable(var::VAR{BayesianEstimated{T, M}}) where {T, M}</code></pre><p>In case of Bayesian estimated VARs, the model is considered stable if and only if the VAR is stable for all parameter draws. As such, a rather strong view is taken here. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/stability_checks.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.make_companion_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#MacroEconometrics.make_companion_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>MacroEconometrics.make_companion_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_companion(B::AbstractMatrix{T}) where {T}</code></pre><p>Create the VAR companion matrix.</p><p>Given a VAR of the form</p><p class="math-container">\[y_t = b_0 + B_1 y_{t-1} + ... + B_p y_{t-p} + \varepsilon_t\]</p><p>The companion matrix is given by </p><p class="math-container">\[C = \begin{bmatrix}
    B_1 &amp; B_2 &amp; \dots &amp; B_{p-1} &amp; B_p \\
    I_n &amp; O &amp; \dots &amp; O &amp; O \\
    O &amp; I_n &amp; &amp; O &amp; O \\
    \vdots &amp; &amp; \ddots &amp; \vdots &amp; \vdots \\ 
    O &amp; O &amp; \dots &amp; I_n &amp; O
\end{bmatrix}\]</p><p>Thus, <span>$B$</span> is a <span>$np\times np$</span> matrix. </p><p><strong>Arguments</strong></p><p>-<code>B::AbstractMatrix{T}</code>: Lag matrix in the form required for a <code>VAR</code> model. See     the documentation of <code>VAR</code>.</p><p><strong>References</strong></p><ul><li>Kilian, L., &amp; Lütkepohl, H. (2017). Structural Vector Autoregressive Analysis: (1st ed.). Cambridge University Press. https://doi.org/10.1017/9781108164818</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/companion_matrix.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.make_companion_matrix-Union{Tuple{VAR{FixedEstimated{T}}}, Tuple{T}} where T" href="#MacroEconometrics.make_companion_matrix-Union{Tuple{VAR{FixedEstimated{T}}}, Tuple{T}} where T"><code>MacroEconometrics.make_companion_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_companion_matrix(var::VAR{FixedEstimated{T}}) where {T}
make_companion_matrix(var::VAR{BayesianEstimated{T, M}}) where {T, M}</code></pre><p>Make the companion matrix corresponding to a VAR model. In case of Bayesian estimated models, the companion matrix is constructed for each draw in each chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/companion_matrix.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.simulate!-Union{Tuple{T}, Tuple{SVAR{FixedEstimated{T}}, Int64}} where T" href="#MacroEconometrics.simulate!-Union{Tuple{T}, Tuple{SVAR{FixedEstimated{T}}, Int64}} where T"><code>MacroEconometrics.simulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simulate a Gaussian SVAR. </p><p><strong>Arguments</strong></p><ul><li><code>svar::SVAR{FixedEstimated{T}}</code>: A <a href="#MacroEconometrics.SVAR"><code>SVAR</code></a> model having <a href="#MacroEconometrics.FixedEstimated"><code>FixedEstimated</code></a> coefficients.</li><li><code>periods::Int</code>: Number of periods to simulate the VAR for</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>burnin::Int=100</code>: Number of periods to use as burnin; The longer the burnin, the less the dependence on the initial values. </li><li><code>initial::AbstractVector{T}=zeros(T, svar.n*svar.p)</code>: Initial values. Should be in companion form, so a vector of length svar.n×svar.p</li><li><code>start_date::Date=Dates.today()</code>: The simulated data will be stored in a TSFrame including dates. Thus, we need a start date. </li><li><code>frequency::DatePeriod=Dates.Quarter(1)</code>: Frequency of data. </li><li><code>rng::Random.AbstractRNG=Random.MersenneTwister()</code>: Random Number Generator</li></ul><p><strong>Returns</strong></p><ul><li>Returns the same <a href="#MacroEconometrics.SVAR"><code>SVAR</code></a> model. The <code>data</code> field in the SVAR model is overwritten with he new simulated data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/simulation.jl#L99-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.simulate!-Union{Tuple{T}, Tuple{VAR{FixedEstimated{T}}, Int64}} where T" href="#MacroEconometrics.simulate!-Union{Tuple{T}, Tuple{VAR{FixedEstimated{T}}, Int64}} where T"><code>MacroEconometrics.simulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simulate a Gaussian VAR. </p><p><strong>Arguments</strong></p><ul><li><code>var::VAR{FixedEstimated{T}}</code>: A VAR model having <code>FixedEstimated</code> coefficients.</li><li><code>periods::Int</code>: Number of periods to simulate the VAR for</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>burnin::Int=100</code>: Number of periods to use as burnin; The longe the burnin, the less the dependence on the initial values. </li><li><code>initial::AbstractVector{T}=zeros(T, var.n*var.p)</code>: Initial values. Should be in companion form, so a vector of length var.n×var.p</li><li><code>start_date::Date=Dates.today()</code>: The simulated data will be stored in a TSFrame including dates. Thus, we need a start date. </li><li><code>frequency::DatePeriod=Dates.Quarter(1)</code>: Frequency of data. </li><li><code>rng::Random.AbstractRNG=Random.MersenneTwister()</code>: Random Number Generator</li></ul><p><strong>Returns</strong></p><ul><li>Returns the same VAR model. The <code>data</code> field in the VAR model is overwritten witht he new simulated data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/simulation.jl#L51-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.stack_last_dim-Tuple{AbstractArray}" href="#MacroEconometrics.stack_last_dim-Tuple{AbstractArray}"><code>MacroEconometrics.stack_last_dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stack_last_dim(arr::AbstractArray)</code></pre><p>Stack the last dimension into the second to last dimension. </p><p>This is useful here, since we generally have the convention that the last dimension reflects the chain, and the second to last dimension the draws. As such, this function stacks the chains such that all draws of all chains are considered together. </p><p><strong>Arguments</strong></p><ul><li><code>arr::AbstractArray</code></li></ul><p><strong>Returns</strong></p><ul><li>returns an array with one dimension less but with the second to last dimension enlarged by a factor equal the size of the last dimension of <code>arr</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/utils.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroEconometrics.to_impact_normalisation-Tuple{S} where S&lt;:StructuralImpulseResponseFunction" href="#MacroEconometrics.to_impact_normalisation-Tuple{S} where S&lt;:StructuralImpulseResponseFunction"><code>MacroEconometrics.to_impact_normalisation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Move from covariance normalisation to impact normalisation. </p><p>Given a SVAR of the form </p><p class="math-container">\[A y_t = b_0 + B_1 y_{t-1} + ... + B_p y_{t-p} + \Sigma^{1/2}\varepsilon\]</p><p>that has been covariance normalised, such that <span>$\Sigma^{1/2}=I$</span>, we can move to a SVAR that is impact normalised - the diagonal of <span>$A$</span> consists of only ones, by premultiplying all matriced by <span>$N = Diag(A)^{-1}$</span> where <span>$Diag(X)$</span> denotes the matrix of the diagonal of <span>$X$</span>. The covariance matrix of the structural errors is then given by <span>$NN&#39;$</span>. </p><p><strong>Arguments</strong></p><ul><li><code>sirfs::&lt;:StructuralImpulseResponseFunction</code> obtained from a <a href="#MacroEconometrics.VAR"><code>VAR</code></a> or <a href="#MacroEconometrics.SVAR"><code>SVAR</code></a> model and using any identification method relying on covariance normalisation. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/IRF/types.jl#L34-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSFrames.lag-Union{Tuple{T}, Tuple{TSFrames.TSFrame, AbstractVector{T}}} where T" href="#TSFrames.lag-Union{Tuple{T}, Tuple{TSFrames.TSFrame, AbstractVector{T}}} where T"><code>TSFrames.lag</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If lag_value is a range or a vector of lags, then a vector of TSFrames will be returned where each element of the vector is one lagged TSFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/enweg/MacroEconometrics.jl/blob/c7298b9f109207bddc5b98ea9cbf276b48990422/src/VAR/utils.jl#L20-L24">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 11 April 2023 13:38">Tuesday 11 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
